# .github/workflows/execute-scripts.yml
name: Execute Python Scripts via Telegram

on:
  # Ejecutar cada 5 minutos para verificar mensajes de Telegram
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch: # Permite ejecutar manualmente
    inputs:
      force_run:
        description: 'Force run all scripts'
        required: false
        default: 'false'
        type: boolean
      skip_interactive:
        description: 'Skip scripts that require Telegram interaction'
        required: false
        default: 'false'
        type: boolean

jobs:
  telegram-listener:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install \
          feedparser \
          requests \
          google-api-python-client \
          google-auth-httplib2 \
          google-auth-oauthlib \
          google-auth \
          pathlib

    - name: Configure git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Check Telegram Messages
      id: check_telegram
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import json
        import os
        import sys
        
        def get_telegram_updates():
            bot_token = os.environ.get('BOT_TOKEN')
            if not bot_token:
                print("BOT_TOKEN no configurado")
                sys.exit(1)
                
            try:
                url = f"https://api.telegram.org/bot{bot_token}/getUpdates"
                response = requests.get(url, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    if data["ok"]:
                        return data["result"]
                return []
            except Exception as e:
                print(f"Error obteniendo updates: {e}")
                return []
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaciÃ³n: {e}")
                return False
        
        # Obtener Ãºltimo update_id desde archivo
        try:
            with open('last_update_id.txt', 'r') as f:
                last_update_id = int(f.read().strip())
        except:
            last_update_id = 0
        
        updates = get_telegram_updates()
        should_run = False
        skip_interactive = False
        new_last_update_id = last_update_id
        
        for update in updates:
            update_id = update["update_id"]
            
            if update_id > last_update_id:
                new_last_update_id = max(new_last_update_id, update_id)
                
                if "message" in update:
                    message = update["message"]
                    text = message.get("text", "").lower().strip()
                    
                    if text in ["yes", "si", "start", "ejecutar", "run"]:
                        should_run = True
                        print("ðŸš€ Comando de ejecuciÃ³n recibido via Telegram")
                        send_notification("ðŸš€ Iniciando automatizaciÃ³n desde GitHub Actions...")
                    
                    elif text in ["auto", "automatic", "skip-interactive"]:
                        should_run = True
                        skip_interactive = True
                        print("ðŸš€ Comando de ejecuciÃ³n automÃ¡tica (sin interacciÃ³n)")
                        send_notification("ðŸš€ Iniciando automatizaciÃ³n en modo automÃ¡tico...")
                    
                    elif text in ["status", "estado"]:
                        send_notification("ðŸ“Š GitHub Actions estÃ¡ ejecutÃ¡ndose cada 5 minutos\nðŸ’¬ 'yes' = ejecuciÃ³n normal\nðŸ¤– 'auto' = sin interacciÃ³n")
        
        # Guardar nuevo last_update_id
        with open('last_update_id.txt', 'w') as f:
            f.write(str(new_last_update_id))
        
        # Establecer outputs para siguientes steps
        if should_run or os.environ.get('GITHUB_EVENT_NAME') == 'workflow_dispatch':
            print("SHOULD_RUN=true")
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("should_run=true\n")
                f.write(f"skip_interactive={'true' if skip_interactive else 'false'}\n")
        else:
            print("SHOULD_RUN=false") 
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("should_run=false\n")
                f.write("skip_interactive=false\n")
        EOF

    - name: Download from Google Drive (only when executing scripts)
      if: steps.check_telegram.outputs.should_run == 'true'
      env:
        GOOGLE_DRIVE_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        import base64
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaIoBaseDownload
        import io
        
        def download_google_drive_folder():
            folder_id = "1-NXHDM29JFrNpzVxMFmfFLMMaNgy44ML"
            
            # Crear carpeta videos si no existe
            os.makedirs("videos", exist_ok=True)
            
            print("ðŸ“ Descargando archivos de Google Drive con Service Account...")
            
            try:
                # Cargar credenciales desde variable de entorno
                credentials_json = os.environ.get('GOOGLE_DRIVE_CREDENTIALS')
                if not credentials_json:
                    print("âŒ GOOGLE_DRIVE_CREDENTIALS no configurado")
                    return
                
                # Parsear credenciales
                credentials_info = json.loads(credentials_json)
                credentials = Credentials.from_service_account_info(
                    credentials_info, 
                    scopes=['https://www.googleapis.com/auth/drive.readonly']
                )
                
                # Crear servicio de Drive
                service = build('drive', 'v3', credentials=credentials)
                
                # Listar archivos en la carpeta
                results = service.files().list(
                    q=f"'{folder_id}' in parents and trashed=false",
                    fields="files(id,name,mimeType,size)"
                ).execute()
                
                files = results.get('files', [])
                print(f"ðŸ” Encontrados {len(files)} archivos")
                
                for file_info in files:
                    file_id = file_info['id']
                    file_name = file_info['name']
                    mime_type = file_info['mimeType']
                    
                    # Solo descargar imÃ¡genes y videos
                    if mime_type.startswith(('image/', 'video/')) or any(
                        ext in file_name.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mkv', '.mov', '.webm']
                    ):
                        print(f"â¬‡ï¸ Descargando: {file_name}")
                        
                        try:
                            # Descargar archivo
                            request = service.files().get_media(fileId=file_id)
                            file_path = os.path.join("videos", file_name)
                            
                            with open(file_path, 'wb') as f:
                                downloader = MediaIoBaseDownload(f, request)
                                done = False
                                while done is False:
                                    status, done = downloader.next_chunk()
                            
                            print(f"âœ… Descargado: {file_name}")
                            
                        except Exception as e:
                            print(f"âŒ Error descargando {file_name}: {e}")
                    else:
                        print(f"â­ï¸ Omitiendo: {file_name} (tipo: {mime_type})")
                
                print("ðŸŽ‰ Descarga de Google Drive completada")
                
            except Exception as e:
                print(f"ðŸ’¥ Error en descarga de Google Drive: {e}")
                import traceback
                traceback.print_exc()
        
        download_google_drive_folder()
        EOF

    - name: Verify ffmpeg installation
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "ðŸ”§ Verificando instalaciÃ³n de ffmpeg..."
        ffmpeg -version
        which ffmpeg

    # FunciÃ³n auxiliar para ejecutar scripts con manejo de errores
    - name: Execute script with error handling
      if: steps.check_telegram.outputs.should_run == 'true'
      id: script_runner
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        SKIP_INTERACTIVE: ${{ steps.check_telegram.outputs.skip_interactive }}
      run: |
        python << 'EOF'
        import subprocess
        import sys
        import os
        import requests
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaciÃ³n: {e}")
                return False
        
        def run_script_with_timeout(script_name, timeout_seconds=300):
            """Ejecuta un script con timeout y manejo de errores"""
            print(f"ðŸ“Š Ejecutando {script_name}...")
            
            # Scripts que pueden requerir interacciÃ³n
            interactive_scripts = ['4_metadataextra.py', '8_edit.py', '9_edit.py', '10_edit.py']
            skip_interactive = os.environ.get('SKIP_INTERACTIVE', 'false') == 'true'
            
            if script_name in interactive_scripts and skip_interactive:
                print(f"â­ï¸ Omitiendo {script_name} (modo automÃ¡tico)")
                return True
            
            try:
                # Ejecutar el script con timeout
                result = subprocess.run([
                    'python', script_name
                ], 
                timeout=timeout_seconds, 
                capture_output=True, 
                text=True
                )
                
                if result.returncode == 0:
                    print(f"âœ… {script_name} ejecutado correctamente")
                    if result.stdout:
                        print(f"Output: {result.stdout[:200]}...")
                    return True
                else:
                    print(f"âŒ {script_name} fallÃ³ con cÃ³digo {result.returncode}")
                    if result.stderr:
                        print(f"Error: {result.stderr[:200]}...")
                    
                    # Notificar error crÃ­tico
                    send_notification(f"âŒ Error en {script_name}:\n{result.stderr[:100]}...")
                    return False
                    
            except subprocess.TimeoutExpired:
                print(f"â° {script_name} excediÃ³ el tiempo lÃ­mite ({timeout_seconds}s)")
                send_notification(f"â° {script_name} excediÃ³ el tiempo lÃ­mite")
                return False
            except Exception as e:
                print(f"ðŸ’¥ Error ejecutando {script_name}: {e}")
                send_notification(f"ðŸ’¥ Error crÃ­tico en {script_name}")
                return False
        
        # Lista de scripts a ejecutar
        scripts = [
            '1_monitor.py',
            '2_levelonefilter.py', 
            '3_metadata.py',
            '4_metadataextra.py',
            '5_update_status.py',
            '6_check_metadata.py',
            '7_uploadable.py',
            '8_edit.py',
            '9_edit.py',
            '10_edit.py',
            '11_updatemetadata.py',
            '12_upload.py',
            '13_clean.py'
        ]
        
        failed_scripts = []
        
        for script in scripts:
            if not run_script_with_timeout(script):
                failed_scripts.append(script)
                
                # Decidir si continuar o parar
                critical_scripts = ['1_monitor.py', '12_upload.py']
                if script in critical_scripts:
                    print(f"ðŸ’€ Script crÃ­tico {script} fallÃ³. Deteniendo ejecuciÃ³n.")
                    send_notification(f"ðŸ’€ EjecuciÃ³n detenida por fallo crÃ­tico en {script}")
                    break
                else:
                    print(f"âš ï¸ {script} fallÃ³ pero continuando...")
        
        # Reporte final
        if failed_scripts:
            failed_list = ', '.join(failed_scripts)
            send_notification(f"âš ï¸ Scripts fallidos: {failed_list}")
            print(f"Scripts fallidos: {failed_list}")
            # No fallar el workflow por scripts no crÃ­ticos
        else:
            print("âœ… Todos los scripts se ejecutaron correctamente")
        
        # Establecer output para el siguiente step
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f"failed_scripts={','.join(failed_scripts)}\n")
            f.write(f"has_failures={'true' if failed_scripts else 'false'}\n")
        EOF

    - name: Check for changes (excluding specific folders)
      if: steps.check_telegram.outputs.should_run == 'true'
      id: check_changes
      run: |
        # Verificar cambios excluyendo las carpetas uploadable y videos
        git add .
        git reset -- uploadable/ videos/ 2>/dev/null || true
        
        # Verificar si hay cambios para commitear
        if git diff --staged --quiet; then
          echo "No hay cambios para commitear (excluyendo uploadable/ y videos/)"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Hay cambios para commitear"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push changes
      if: steps.check_telegram.outputs.should_run == 'true' && steps.check_changes.outputs.has_changes == 'true'
      run: |
        # Hacer commit solo de los archivos que no estÃ¡n en uploadable/ y videos/
        git commit -m "ðŸ¤– Automated update: $(date '+%Y-%m-%d %H:%M:%S UTC')"
        git push origin ${{ github.ref_name }}

    - name: Send completion notification
      if: steps.check_telegram.outputs.should_run == 'true'
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaciÃ³n: {e}")
                return False
        
        completion_time = datetime.now().strftime('%H:%M:%S')
        has_failures = os.environ.get('has_failures', 'false') == 'true'
        
        if has_failures:
            status_emoji = "âš ï¸"
            status_text = "completada con advertencias"
        else:
            status_emoji = "âœ…"
            status_text = "completada exitosamente"
        
        final_msg = f"{status_emoji} AutomatizaciÃ³n {status_text} - {completion_time}\nðŸ’¬ 'yes' = ejecuciÃ³n normal\nðŸ¤– 'auto' = sin interacciÃ³n"
        send_notification(final_msg)
        EOF

    - name: Update last_update_id file
      if: always()
      run: |
        # Commitear el archivo last_update_id para mantener el tracking
        if [ -f last_update_id.txt ]; then
          git add last_update_id.txt
          git commit -m "Update Telegram last_update_id" || echo "No changes to last_update_id"
          git push origin ${{ github.ref_name }} || echo "No push needed"
        fi
