name: Execute Python Scripts via Telegram

on:
  # Webhook desde Azure y manual (SIN cron schedule)
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run all scripts'
        required: false
        default: 'false'
        type: boolean
  
  repository_dispatch:
    types: [telegram_trigger]

jobs:
  telegram-listener:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install \
          feedparser \
          requests \
          google-api-python-client \
          google-auth-httplib2 \
          google-auth-oauthlib \
          google-auth \
          pathlib

    - name: Configure git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Download from Google Drive
      env:
        GOOGLE_DRIVE_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        import base64
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaIoBaseDownload
        import io
        
        def download_google_drive_folder():
            folder_id = "1-NXHDM29JFrNpzVxMFmfFLMMaNgy44ML"
            
            # Crear carpeta videos si no existe
            os.makedirs("videos", exist_ok=True)
            
            print("ðŸ“ Descargando archivos de Google Drive con Service Account...")
            
            try:
                # Cargar credenciales desde variable de entorno
                credentials_json = os.environ.get('GOOGLE_DRIVE_CREDENTIALS')
                if not credentials_json:
                    print("âŒ GOOGLE_DRIVE_CREDENTIALS no configurado")
                    return
                
                # Parsear credenciales
                credentials_info = json.loads(credentials_json)
                credentials = Credentials.from_service_account_info(
                    credentials_info, 
                    scopes=['https://www.googleapis.com/auth/drive.readonly']
                )
                
                # Crear servicio de Drive
                service = build('drive', 'v3', credentials=credentials)
                
                # Listar archivos en la carpeta
                results = service.files().list(
                    q=f"'{folder_id}' in parents and trashed=false",
                    fields="files(id,name,mimeType,size)"
                ).execute()
                
                files = results.get('files', [])
                print(f"ðŸ” Encontrados {len(files)} archivos")
                
                for file_info in files:
                    file_id = file_info['id']
                    file_name = file_info['name']
                    mime_type = file_info['mimeType']
                    
                    # Solo descargar imÃ¡genes y videos
                    if mime_type.startswith(('image/', 'video/')) or any(
                        ext in file_name.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mkv', '.mov', '.webm']
                    ):
                        print(f"â¬‡ï¸ Descargando: {file_name}")
                        
                        try:
                            # Descargar archivo
                            request = service.files().get_media(fileId=file_id)
                            file_path = os.path.join("videos", file_name)
                            
                            with open(file_path, 'wb') as f:
                                downloader = MediaIoBaseDownload(f, request)
                                done = False
                                while done is False:
                                    status, done = downloader.next_chunk()
                            
                            print(f"âœ… Descargado: {file_name}")
                            
                        except Exception as e:
                            print(f"âŒ Error descargando {file_name}: {e}")
                    else:
                        print(f"â­ï¸ Omitiendo: {file_name} (tipo: {mime_type})")
                
                print("ðŸŽ‰ Descarga de Google Drive completada")
                
            except Exception as e:
                print(f"ðŸ’¥ Error en descarga de Google Drive: {e}")
                import traceback
                traceback.print_exc()
        
        download_google_drive_folder()
        EOF

    - name: Verify ffmpeg installation
      run: |
        echo "ðŸ”§ Verificando instalaciÃ³n de ffmpeg..."
        ffmpeg -version
        which ffmpeg

    - name: Execute 1_monitor.py
      run: |
        echo "ðŸ“Š Ejecutando 1_monitor.py..."
        python 1_monitor.py

    - name: Execute 2_levelonefilter.py
      run: |
        echo "ðŸ” Ejecutando 2_levelonefilter.py..."
        python 2_levelonefilter.py

    - name: Execute 3_metadata.py
      run: |
        echo "ðŸ“ Ejecutando 3_metadata.py..."
        python 3_metadata.py

    - name: Execute 4_metadataextra.py
      run: |
        echo "ðŸ“‹ Ejecutando 4_metadataextra.py..."
        python 4_metadataextra.py

    - name: Execute 5_update_status.py
      run: |
        echo "ðŸ”„ Ejecutando 5_update_status.py..."
        python 5_update_status.py

    - name: Execute 6_check_metadata.py
      run: |
        echo "âœ… Ejecutando 6_check_metadata.py..."
        python 6_check_metadata.py

    - name: Execute 7_uploadable.py
      run: |
        echo "ðŸ“¤ Ejecutando 7_uploadable.py..."
        python 7_uploadable.py

    - name: Execute 8_edit.py
      run: |
        echo "âœï¸ Ejecutando 8_edit.py..."
        python 8_edit.py

    - name: Execute 9_edit.py
      run: |
        echo "âœï¸ Ejecutando 9_edit.py..."
        python 9_edit.py

    - name: Execute 10_edit.py
      run: |
        echo "âœï¸ Ejecutando 10_edit.py..."
        python 10_edit.py

    - name: Execute 11_updatemetadata.py
      env:
        CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "ðŸ”„ Ejecutando 11_updatemetadata.py..."
        python 11_updatemetadata.py

    - name: Execute 12_upload.py
      run: |
        echo "â˜ï¸ Ejecutando 12_upload.py..."
        timeout 300s python 12_upload.py || echo "âš ï¸ 12_upload.py terminado por timeout o completado"

    - name: Execute 13_clean.py
      run: |
        echo "ðŸ§¹ Ejecutando 13_clean.py..."
        python 13_clean.py
        
    - name: Check for changes (excluding specific folders)
      id: check_changes
      run: |
        # Verificar cambios excluyendo las carpetas uploadable y videos
        git add .
        git reset -- uploadable/ videos/ 2>/dev/null || true
        
        # Verificar si hay cambios para commitear
        if git diff --staged --quiet; then
          echo "No hay cambios para commitear (excluyendo uploadable/ y videos/)"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Hay cambios para commitear"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        # Hacer commit solo de los archivos que no estÃ¡n en uploadable/ y videos/
        git commit -m "ðŸ¤– Automated update: $(date '+%Y-%m-%d %H:%M:%S UTC')"
        git push origin ${{ github.ref_name }}

    - name: Send completion notification
      if: always()
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaciÃ³n: {e}")
                return False
        
        completion_time = datetime.now().strftime('%H:%M:%S')
        final_msg = f"âœ… AutomatizaciÃ³n completada - {completion_time}\nðŸ’¬ Escribe 'start' para ejecutar de nuevo"
        send_notification(final_msg)
        EOF
