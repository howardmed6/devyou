# .github/workflows/execute-scripts.yml
name: Execute Python Scripts via Telegram

on:
  # Ejecutar cada 5 minutos para verificar mensajes de Telegram
  schedule:
    - cron: '*/5 * * * *'
  workflow_dispatch: # Permite ejecutar manualmente
    inputs:
      force_run:
        description: 'Force run all scripts'
        required: false
        default: 'false'
        type: boolean

jobs:
  telegram-listener:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install \
          feedparser \
          requests \
          google-api-python-client \
          google-auth-httplib2 \
          google-auth-oauthlib \
          google-auth \
          pathlib

    - name: Configure git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Check Telegram Messages
      id: check_telegram
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import json
        import os
        import sys
        
        def get_telegram_updates():
            bot_token = os.environ.get('BOT_TOKEN')
            if not bot_token:
                print("BOT_TOKEN no configurado")
                sys.exit(1)
                
            try:
                url = f"https://api.telegram.org/bot{bot_token}/getUpdates"
                response = requests.get(url, timeout=10)
                
                if response.status_code == 200:
                    data = response.json()
                    if data["ok"]:
                        return data["result"]
                return []
            except Exception as e:
                print(f"Error obteniendo updates: {e}")
                return []
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaci√≥n: {e}")
                return False
        
        # Obtener √∫ltimo update_id desde archivo
        try:
            with open('last_update_id.txt', 'r') as f:
                last_update_id = int(f.read().strip())
        except:
            last_update_id = 0
        
        updates = get_telegram_updates()
        should_run = False
        new_last_update_id = last_update_id
        
        for update in updates:
            update_id = update["update_id"]
            
            if update_id > last_update_id:
                new_last_update_id = max(new_last_update_id, update_id)
                
                if "message" in update:
                    message = update["message"]
                    text = message.get("text", "").lower().strip()
                    
                    if text in ["yes", "si", "start", "ejecutar", "run"]:
                        should_run = True
                        print("üöÄ Comando de ejecuci√≥n recibido via Telegram")
                        send_notification("üöÄ Iniciando automatizaci√≥n desde GitHub Actions...")
                    
                    elif text in ["status", "estado"]:
                        send_notification("üìä GitHub Actions est√° ejecut√°ndose cada 5 minutos\nüí¨ Escribe 'yes' para ejecutar scripts ahora")
        
        # Guardar nuevo last_update_id
        with open('last_update_id.txt', 'w') as f:
            f.write(str(new_last_update_id))
        
        # Establecer output para siguiente step
        if should_run or os.environ.get('GITHUB_EVENT_NAME') == 'workflow_dispatch':
            print("SHOULD_RUN=true")
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("should_run=true\n")
        else:
            print("SHOULD_RUN=false") 
            with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                f.write("should_run=false\n")
        EOF

    - name: Download from Google Drive (only when executing scripts)
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        python << 'EOF'
        import requests
        import os
        import re
        from urllib.parse import unquote
        
        def download_google_drive_folder():
            folder_url = "https://drive.google.com/drive/folders/1-NXHDM29JFrNpzVxMFmfFLMMaNgy44ML"
            
            # Crear carpeta videos si no existe
            os.makedirs("videos", exist_ok=True)
            
            print("üìÅ Descargando archivos de Google Drive...")
            
            try:
                # Obtener la p√°gina HTML de la carpeta p√∫blica
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
                response = requests.get(folder_url, headers=headers, timeout=30)
                
                if response.status_code == 200:
                    html_content = response.text
                    
                    # Buscar archivos en el HTML usando regex
                    # Patr√≥n para encontrar archivos con sus IDs
                    file_pattern = r'\["([^"]+)","([^"]+)",[^,]*,"([^"]*)"[^]]*\]'
                    matches = re.findall(file_pattern, html_content)
                    
                    if not matches:
                        # M√©todo alternativo: buscar IDs directamente
                        id_pattern = r'"([a-zA-Z0-9_-]{25,})"'
                        file_ids = list(set(re.findall(id_pattern, html_content)))
                        
                        print(f"üîç Encontrados {len(file_ids)} posibles archivos")
                        
                        for i, file_id in enumerate(file_ids[:20]):  # Limitar a 20 para evitar spam
                            print(f"‚¨áÔ∏è Intentando descargar archivo {i+1}...")
                            
                            # Probar descarga directa
                            download_url = f"https://drive.google.com/uc?export=download&id={file_id}"
                            
                            try:
                                file_response = requests.get(download_url, stream=True, timeout=30, headers=headers)
                                
                                # Verificar si es un archivo v√°lido
                                content_type = file_response.headers.get('content-type', '')
                                if file_response.status_code == 200 and (
                                    content_type.startswith(('image/', 'video/')) or 
                                    len(file_response.content) > 1000
                                ):
                                    # Intentar obtener nombre del archivo
                                    content_disposition = file_response.headers.get('content-disposition', '')
                                    if 'filename=' in content_disposition:
                                        filename = content_disposition.split('filename=')[1].strip('"')
                                    else:
                                        # Generar nombre basado en content-type
                                        if content_type.startswith('image/'):
                                            ext = content_type.split('/')[-1]
                                            filename = f"image_{i+1}.{ext}"
                                        elif content_type.startswith('video/'):
                                            ext = content_type.split('/')[-1]
                                            filename = f"video_{i+1}.{ext}"
                                        else:
                                            filename = f"file_{i+1}.bin"
                                    
                                    file_path = os.path.join("videos", filename)
                                    with open(file_path, 'wb') as f:
                                        for chunk in file_response.iter_content(chunk_size=8192):
                                            if chunk:
                                                f.write(chunk)
                                    print(f"‚úÖ Descargado: {filename}")
                                    
                            except Exception as e:
                                print(f"‚ùå Error descargando archivo {i+1}: {e}")
                    else:
                        print(f"üîç Encontrados {len(matches)} archivos")
                        for match in matches:
                            file_id, file_name, mime_type = match
                            
                            # Solo descargar si parece ser imagen o video
                            if any(ext in file_name.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mkv', '.mov', '.webm']):
                                print(f"‚¨áÔ∏è Descargando: {file_name}")
                                
                                download_url = f"https://drive.google.com/uc?export=download&id={file_id}"
                                
                                try:
                                    file_response = requests.get(download_url, stream=True, timeout=30, headers=headers)
                                    if file_response.status_code == 200:
                                        file_path = os.path.join("videos", file_name)
                                        with open(file_path, 'wb') as f:
                                            for chunk in file_response.iter_content(chunk_size=8192):
                                                if chunk:
                                                    f.write(chunk)
                                        print(f"‚úÖ Descargado: {file_name}")
                                    else:
                                        print(f"‚ùå Error descargando {file_name}: {file_response.status_code}")
                                except Exception as e:
                                    print(f"‚ùå Error descargando {file_name}: {e}")
                    
                    print("üéâ Descarga de Google Drive completada")
                else:
                    print(f"‚ùå Error accediendo a la carpeta: {response.status_code}")
                    
            except Exception as e:
                print(f"üí• Error en descarga de Google Drive: {e}")
        
        download_google_drive_folder()
        EOF

    - name: Execute 1_monitor.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üìä Ejecutando 1_monitor.py..."
        python 1_monitor.py

    - name: Execute 2_levelonefilter.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üîç Ejecutando 2_levelonefilter.py..."
        python 2_levelonefilter.py

    - name: Execute 3_metadata.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üìù Ejecutando 3_metadata.py..."
        python 3_metadata.py

    - name: Execute 4_metadataextra.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üìã Ejecutando 4_metadataextra.py..."
        python 4_metadataextra.py

    - name: Execute 5_update_status.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üîÑ Ejecutando 5_update_status.py..."
        python 5_update_status.py

    - name: Execute 6_check_metadata.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "‚úÖ Ejecutando 6_check_metadata.py..."
        python 6_check_metadata.py

    - name: Execute 7_uploadable.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üì§ Ejecutando 7_uploadable.py..."
        python 7_uploadable.py

    - name: Execute 8_edit.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "‚úèÔ∏è Ejecutando 8_edit.py..."
        python 8_edit.py

    - name: Execute 9_edit.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "‚úèÔ∏è Ejecutando 9_edit.py..."
        python 9_edit.py

    - name: Execute 10_edit.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "‚úèÔ∏è Ejecutando 10_edit.py..."
        python 10_edit.py

    - name: Execute 11_updatemetadata.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üîÑ Ejecutando 11_updatemetadata.py..."
        python 11_updatemetadata.py

    - name: Execute 12_upload.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "‚òÅÔ∏è Ejecutando 12_upload.py..."
        python 12_upload.py

    - name: Execute 13_clean.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "üßπ Ejecutando 13_clean.py..."
        python 13_clean.py

    - name: Execute 14_add_manual.py
      if: steps.check_telegram.outputs.should_run == 'true'
      run: |
        echo "‚ûï Ejecutando 14_add_manual.py..."
        python 14_add_manual.py

    - name: Check for changes (excluding specific folders)
      if: steps.check_telegram.outputs.should_run == 'true'
      id: check_changes
      run: |
        # Verificar cambios excluyendo las carpetas uploadable y videos
        git add .
        git reset -- uploadable/ videos/ 2>/dev/null || true
        
        # Verificar si hay cambios para commitear
        if git diff --staged --quiet; then
          echo "No hay cambios para commitear (excluyendo uploadable/ y videos/)"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Hay cambios para commitear"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push changes
      if: steps.check_telegram.outputs.should_run == 'true' && steps.check_changes.outputs.has_changes == 'true'
      run: |
        # Hacer commit solo de los archivos que no est√°n en uploadable/ y videos/
        git commit -m "ü§ñ Automated update: $(date '+%Y-%m-%d %H:%M:%S UTC')"
        git push origin ${{ github.ref_name }}

    - name: Send completion notification
      if: steps.check_telegram.outputs.should_run == 'true'
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaci√≥n: {e}")
                return False
        
        completion_time = datetime.now().strftime('%H:%M:%S')
        final_msg = f"‚úÖ Automatizaci√≥n completada - {completion_time}\nüí¨ Escribe 'yes' para ejecutar de nuevo"
        send_notification(final_msg)
        EOF

    - name: Update last_update_id file
      if: always()
      run: |
        # Commitear el archivo last_update_id para mantener el tracking
        if [ -f last_update_id.txt ]; then
          git add last_update_id.txt
          git commit -m "Update Telegram last_update_id" || echo "No changes to last_update_id"
          git push origin ${{ github.ref_name }} || echo "No push needed"
        fi
