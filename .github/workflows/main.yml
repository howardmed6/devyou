name: Execute Python Scripts via Telegram

on:
  # Webhook desde Azure y manual (SIN cron schedule)
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run all scripts'
        required: false
        default: 'false'
        type: boolean
  
  repository_dispatch:
    types: [telegram_trigger]

jobs:
  telegram-listener:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install \
          feedparser \
          requests \
          google-api-python-client \
          google-auth-httplib2 \
          google-auth-oauthlib \
          google-auth \
          pathlib
          yt-dlp

    - name: Configure git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Download from Google Drive
      env:
        GOOGLE_DRIVE_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        import base64
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaIoBaseDownload
        import io
        
        def download_video_and_thumbnail():
            folder_id = "1-NXHDM29JFrNpzVxMFmfFLMMaNgy44ML"
            
            os.makedirs("videos", exist_ok=True)
            
            print("ðŸ“ Descargando video + miniatura de Google Drive...")
            
            try:
                credentials_json = os.environ.get('GOOGLE_DRIVE_CREDENTIALS')
                if not credentials_json:
                    print("âŒ GOOGLE_DRIVE_CREDENTIALS no configurado")
                    return
                
                credentials_info = json.loads(credentials_json)
                credentials = Credentials.from_service_account_info(
                    credentials_info, 
                    scopes=['https://www.googleapis.com/auth/drive.readonly']
                )
                
                service = build('drive', 'v3', credentials=credentials)
                
                # 1. Buscar el video MP4
                results = service.files().list(
                    q=f"'{folder_id}' in parents and mimeType contains 'video/mp4' and trashed=false",
                    fields="files(id,name)"
                ).execute()
                
                videos = results.get('files', [])
                
                if not videos:
                    print("âŒ No se encontrÃ³ video MP4 en Drive")
                    return
                
                video = videos[0]
                video_name = video['name']
                base_name = os.path.splitext(video_name)[0]
                
                print(f"ðŸŽ¬ Video encontrado: {video_name}")
                print(f"ðŸ“ Nombre base: {base_name}")
                
                # 2. Descargar el video
                print(f"â¬‡ï¸ Descargando video...")
                request = service.files().get_media(fileId=video['id'])
                video_path = os.path.join("videos", video_name)
                
                with open(video_path, 'wb') as f:
                    downloader = MediaIoBaseDownload(f, request)
                    done = False
                    while not done:
                        status, done = downloader.next_chunk()
                
                print(f"âœ… Video descargado: {video_name}")
                
                # 3. Buscar la imagen con el mismo nombre base
                thumbnail_name = f"{base_name}.jpg"
                
                results = service.files().list(
                    q=f"'{folder_id}' in parents and name='{thumbnail_name}' and trashed=false",
                    fields="files(id,name)"
                ).execute()
                
                thumbnails = results.get('files', [])
                
                if not thumbnails:
                    print(f"âš ï¸ No se encontrÃ³ miniatura: {thumbnail_name}")
                    print("â„¹ï¸ AsegÃºrate de haber quitado el nÃºmero a la imagen elegida")
                    return
                
                thumbnail = thumbnails[0]
                
                # 4. Descargar la miniatura
                print(f"â¬‡ï¸ Descargando miniatura: {thumbnail_name}")
                request = service.files().get_media(fileId=thumbnail['id'])
                thumbnail_path = os.path.join("videos", thumbnail_name)
                
                with open(thumbnail_path, 'wb') as f:
                    downloader = MediaIoBaseDownload(f, request)
                    done = False
                    while not done:
                        status, done = downloader.next_chunk()
                
                print(f"âœ… Miniatura descargada: {thumbnail_name}")
                print("ðŸŽ‰ Descarga completada: 1 video + 1 miniatura")
                
            except Exception as e:
                print(f"ðŸ’¥ Error en descarga: {e}")
                import traceback
                traceback.print_exc()
        
        download_video_and_thumbnail()
        EOF

    - name: Verify ffmpeg installation
      run: |
        echo "ðŸ”§ Verificando instalaciÃ³n de ffmpeg..."
        ffmpeg -version
        which ffmpeg

    - name: Execute 1_monitor.py
      run: |
        echo "ðŸ“Š Ejecutando 1_monitor.py..."
        python 1_monitor.py

    - name: Execute 2_levelonefilter.py
      run: |
        echo "ðŸ” Ejecutando 2_levelonefilter.py..."
        python 2_levelonefilter.py

    - name: Execute 3_metadata.py
      run: |
        echo "ðŸ“ Ejecutando 3_metadata.py..."
        python 3_metadata.py

    - name: Execute 4_metadataextra.py
      run: |
        echo "ðŸ“‹ Ejecutando 4_metadataextra.py..."
        python 4_metadataextra.py

    - name: Execute 5_update_status.py
      run: |
        echo "ðŸ”„ Ejecutando 5_update_status.py..."
        python 5_update_status.py

    - name: Execute 6_check_metadata.py
      run: |
        echo "âœ… Ejecutando 6_check_metadata.py..."
        python 6_check_metadata.py

    - name: Execute 7_uploadable.py
      run: |
        echo "ðŸ“¤ Ejecutando 7_uploadable.py..."
        python 7_uploadable.py

    - name: Execute 8_edit.py
      run: |
        echo "âœï¸ Ejecutando 8_edit.py..."
        python 8_edit.py

    - name: Execute 9_edit.py
      run: |
        echo "âœï¸ Ejecutando 9_edit.py..."
        python 9_edit.py

    - name: Execute 10_edit.py
      run: |
        echo "âœï¸ Ejecutando 10_edit.py..."
        python 10_edit.py

    - name: Execute 11_updatemetadata.py
      env:
        CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "ðŸ”„ Ejecutando 11_updatemetadata.py..."
        python 11_updatemetadata.py

    - name: Execute 12_upload.py (Auto Upload)
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "â˜ï¸ Ejecutando 12_upload.py (subida automÃ¡tica)..."
        python 12_upload.py
        
    - name: Execute 13_clean.py
      run: |
        echo "ðŸ§¹ Ejecutando 13_clean.py..."
        python 13_clean.py
        
    - name: Check for changes (excluding specific folders)
      id: check_changes
      run: |
        git add .
        # AÃ±adimos youtube_token.json para que GitHub no bloquee el push
        git reset -- uploadable/ videos/ youtube_token.json 2>/dev/null || true
        
        # Verificar si hay cambios para commitear
        if git diff --staged --quiet; then
          echo "No hay cambios para commitear (excluyendo uploadable/ y videos/)"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        else
          echo "Hay cambios para commitear"
          echo "has_changes=true" >> $GITHUB_OUTPUT
        fi

    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        # Hacer commit solo de los archivos que no estÃ¡n en uploadable/ y videos/
        git commit -m "ðŸ¤– Automated update: $(date '+%Y-%m-%d %H:%M:%S UTC')"
        git push origin ${{ github.ref_name }}

    - name: Send completion notification
      if: always()
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaciÃ³n: {e}")
                return False
        
        completion_time = datetime.now().strftime('%H:%M:%S')
        final_msg = f"âœ… AutomatizaciÃ³n completada - {completion_time}\nðŸ’¬ Escribe 'start' para ejecutar de nuevo"
        send_notification(final_msg)
        EOF
