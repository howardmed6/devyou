name: Execute Python Scripts via Telegram Webhook

on:
  # Solo activaci√≥n manual y por webhook (SIN cron schedule)
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run all scripts'
        required: false
        default: 'true'
        type: boolean
  
  # Webhook desde Azure (repository_dispatch)
  repository_dispatch:
    types: [telegram_trigger]

jobs:
  execute-scripts:
    runs-on: ubuntu-latest
    
    steps:
    - name: Show trigger info
      run: |
        echo "üöÄ Workflow disparado por: ${{ github.event_name }}"
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          echo "üì° Trigger: Webhook desde Azure"
          echo "‚è∞ Timestamp: ${{ github.event.client_payload.timestamp }}"
        else
          echo "üë§ Trigger: Manual"
        fi

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install \
          feedparser \
          requests \
          google-api-python-client \
          google-auth-httplib2 \
          google-auth-oauthlib \
          google-auth \
          pathlib

    - name: Configure git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Send start notification
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url, 
                    {"chat_id": chat_id, "text": message, "parse_mode": "HTML"}, 
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaci√≥n: {e}")
                return False
        
        start_time = datetime.now().strftime('%H:%M:%S')
        trigger_type = "${{ github.event_name }}"
        
        if trigger_type == "repository_dispatch":
            msg = f"üöÄ <b>Procesamiento iniciado por webhook</b> - {start_time}\n‚ö° Respuesta instant√°nea activada"
        else:
            msg = f"üöÄ <b>Procesamiento iniciado manualmente</b> - {start_time}"
            
        send_notification(msg)
        EOF

    - name: Download from Google Drive
      env:
        GOOGLE_DRIVE_CREDENTIALS: ${{ secrets.GOOGLE_DRIVE_CREDENTIALS }}
      run: |
        python << 'EOF'
        import requests
        import os
        import json
        import base64
        from google.oauth2.service_account import Credentials
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaIoBaseDownload
        import io
        
        def download_google_drive_folder():
            folder_id = "1-NXHDM29JFrNpzVxMFmfFLMMaNgy44ML"
            
            # Crear carpeta videos si no existe
            os.makedirs("videos", exist_ok=True)
            
            print("üìÅ Descargando archivos de Google Drive con Service Account...")
            
            try:
                # Cargar credenciales desde variable de entorno
                credentials_json = os.environ.get('GOOGLE_DRIVE_CREDENTIALS')
                if not credentials_json:
                    print("‚ùå GOOGLE_DRIVE_CREDENTIALS no configurado")
                    return
                
                # Parsear credenciales
                credentials_info = json.loads(credentials_json)
                credentials = Credentials.from_service_account_info(
                    credentials_info, 
                    scopes=['https://www.googleapis.com/auth/drive.readonly']
                )
                
                # Crear servicio de Drive
                service = build('drive', 'v3', credentials=credentials)
                
                # Listar archivos en la carpeta
                results = service.files().list(
                    q=f"'{folder_id}' in parents and trashed=false",
                    fields="files(id,name,mimeType,size)"
                ).execute()
                
                files = results.get('files', [])
                print(f"üîç Encontrados {len(files)} archivos")
                
                for file_info in files:
                    file_id = file_info['id']
                    file_name = file_info['name']
                    mime_type = file_info['mimeType']
                    
                    # Solo descargar im√°genes y videos
                    if mime_type.startswith(('image/', 'video/')) or any(
                        ext in file_name.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mkv', '.mov', '.webm']
                    ):
                        print(f"‚¨áÔ∏è Descargando: {file_name}")
                        
                        try:
                            # Descargar archivo
                            request = service.files().get_media(fileId=file_id)
                            file_path = os.path.join("videos", file_name)
                            
                            with open(file_path, 'wb') as f:
                                downloader = MediaIoBaseDownload(f, request)
                                done = False
                                while done is False:
                                    status, done = downloader.next_chunk()
                            
                            print(f"‚úÖ Descargado: {file_name}")
                            
                        except Exception as e:
                            print(f"‚ùå Error descargando {file_name}: {e}")
                    else:
                        print(f"‚è≠Ô∏è Omitiendo: {file_name} (tipo: {mime_type})")
                
                print("üéâ Descarga de Google Drive completada")
                
            except Exception as e:
                print(f"üí• Error en descarga de Google Drive: {e}")
                import traceback
                traceback.print_exc()
        
        download_google_drive_folder()
        EOF

    - name: Execute all scripts
      env:
        CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        echo "üìä Ejecutando secuencia completa..."
        
        # Lista de scripts a ejecutar
        scripts=("1_monitor.py" "2_levelonefilter.py" "3_metadata.py" "4_metadataextra.py" "5_update_status.py" "6_check_metadata.py" "7_uploadable.py" "8_edit.py" "9_edit.py" "10_edit.py" "11_updatemetadata.py")
        
        for script in "${scripts[@]}"; do
          echo "üîÑ Ejecutando $script..."
          python "$script" || echo "‚ö†Ô∏è Error en $script, continuando..."
        done
        
        echo "‚òÅÔ∏è Ejecutando upload..."
        timeout 300s python 12_upload.py || echo "‚ö†Ô∏è Upload terminado"
        
        echo "üßπ Limpiando..."
        python 13_clean.py

    - name: Commit changes
      run: |
        git add .
        git reset -- uploadable/ videos/ 2>/dev/null || true
        git diff --staged --quiet || {
          git commit -m "ü§ñ Automated update via webhook: $(date)"
          git push origin ${{ github.ref_name }}
        }

    - name: Send completion notification
      if: always()
      env:
        BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
        CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      run: |
        python << 'EOF'
        import requests
        import os
        from datetime import datetime
        
        def send_notification(message):
            bot_token = os.environ.get('BOT_TOKEN')
            chat_id = os.environ.get('CHAT_ID')
            
            try:
                url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                response = requests.post(
                    url,
                    {"chat_id": chat_id, "text": message, "parse_mode": "HTML"},
                    timeout=10
                )
                return response.status_code == 200
            except Exception as e:
                print(f"Error enviando notificaci√≥n: {e}")
                return False
        
        completion_time = datetime.now().strftime('%H:%M:%S')
        job_status = "${{ job.status }}"
        
        if job_status == "success":
            final_msg = f"""‚úÖ <b>Automatizaci√≥n completada</b> - {completion_time}
            
‚ö° <b>Webhook activo</b> - Respuesta instant√°nea
üí¨ Escribe <code>start</code> para ejecutar de nuevo
üìä <a href="https://github.com/${{ github.repository }}/actions">Ver Actions</a>"""
        else:
            final_msg = f"""‚ùå <b>Error en automatizaci√≥n</b> - {completion_time}
            
üîß <a href="https://github.com/${{ github.repository }}/actions">Revisar logs</a>
üí¨ Escribe <code>start</code> para reintentar"""
            
        send_notification(final_msg)
        EOF
